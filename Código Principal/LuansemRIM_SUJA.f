      PROGRAM MAIN
C
C	PROGRAMA COM ELEMENTOS LINEARES PARA INTERPOLAÇÃO DO PROBLEMA DE HELMHOTZ
C	 VERSÃO COM CALCULO DE NOVA ESTRATÉGIA SEM TERMO REGULARIZADOR	MECIC
C     USAM-SE NOVAS FUNÇOES, A SOL FUNDAMENTAL E O TENSOR DE GALERKIN
C      PROBLEMA DE RESPOSTA COM SOL ANALITICA IMPLEMENTADA 
      
	IMPLICIT NONE
      COMMON NE,NP,L,LEC,IMP,NPI,NT
	INTEGER NX,LEC,IMP
	PARAMETER (NX=2000)
 	INTEGER CONT_UPRES,CONT_QPRES,CONT_INTF,NUM(NX),NUM_2(NX)
	INTEGER NOP(NX,3),KODE(NX),LOCC(NX),IDUP(NX),NE,NP,L,NPI,NT,PRINTE
 	REAL*8 X(NX),Y(NX),G(NX,NX),FI(NX),DFI(NX),XXC(NX)
	REAL*8 YYC(NX),SOL(NX),H(NX,NX),DSOLX(NX),DSOLY(NX)
	REAL*8 A(NX,NX),B(NX,NX),CB(NX),XX(NX),YY(NX),D,DIST
	REAL*8 TEMPO,CALCULA_TEMPO,FR
	CHARACTER SAI*20,TEMPO1*10,TEMPO2*10,ARQENT*20
      INTEGER Z
      INTEGER*4 DATE_TIME(8)
      CHARACTER*8 TIMENOW(3)
	
	!NX EH A VARIAVEL QUE DEFINE O TAMANHO DAS 
	!MATRIZES A SEREM CALCULADAS DENTRO DO CODIGO
      										    
	!A EQUACAO SENDO CALCULADA ERA  [HU-GQ=(LAMBIDA^2)MU]
	!A EQUACAO A SER CALCULADA SERA [HU-GQ+(LAMBIDA)WU-(LAMBIDA)SQ=(LAMBIDA^2)MU]

	LEC=5	 !VARIAVEIS UTILIZADAS SOMENTE PARA IMPRIMIR RESULTADOS
	IMP=6    !VARIAVEIS UTILIZADAS SOMENTE PARA IMPRIMIR RESULTADOS
	PRINTE=1 !VARIAVEIS UTILIZADAS SOMENTE PARA IMPRIMIR RESULTADOS


!*************************************************************************************************
C      !DIGITE A MALHA QUE SERÁ UTILIZADA														  !*
C	 !NOME DA MATRIZ UTILIZADA 	         !PROBLEMA ENCONTRADO								  !*
C      ARQENT = '3249ENG.TXT'		         !													  !*
      ARQENT = '3249MEM.TXT'		         !													  !*
C      ARQENT = '3264.TXT'		         !													  !*
C      ARQENT = '3264ENG.TXT'		         !													  !*
C      ARQENT = '3264MEM.TXT'			     !													  !*
C      ARQENT = '3281ENG.TXT'			     !													  !*
C      ARQENT = '3281MEM.TXT'			     !													  !*
C      ARQENT = '3608.TXT'			     ! 													  !*
C      ARQENT = '8449ENG.TXT'			     !													  !*
C      ARQENT = '8480ENG.TXT'			     !													  !*
C      ARQENT = '8480MEM.TXT'			     !													  !*
C      ARQENT = '16480ENG.TXT'		     !													  !*
C      ARQENT = '84144.TXT'			     !													  !*
C      ARQENT = '84144ENG.TXT'		     !													  !*
C      ARQENT = '84144MEM.TXT'			 !                                                    !*							
C      ARQENT = '160484.TXT'               !ERRO DE MATRIZ SINGULAR							  !*
C      ARQENT = '160484MEMB.TXT'           !NAO FINALIZA.										  !*
C      ARQENT = '164144ENG.TXT'            !													  !*
C      ARQENT = '164144MEM.TXT'	         !													  !*
C      ARQENT = '164484ENG.TXT'            !ERRO DE MATRIZ SINGULAR							  !*
C      ARQENT = '164484MEM.TXT'	         !													  !*
C      ARQENT = '320324.TXT'		         !													  !*
C      ARQENT = '320576.TXT'               !ERRO DE MATRIZ SINGULAR							  !* 	
!*************************************************************************************************

	!CALCULO DO TEMPO DE PROCESSAMENTO%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	
      FR = 2.0 !NAO ESTA SENDO UTILIZADO, POIS SE CALCULAVA OMEGA A PARTIR DESTE
			 !AGORA OMEGA ESTÁ TENDO VALOR ATRIBUIDO DE ZERO, E ESTE NAO FOI 
			 !APAGADO PARA EVITAR PROBLEMAS NO CODIGO.

	!WRITE(*,'(A\)')' INFORME NOME DO ARQUIVO DE ENTRADA-->'
      !READ(*,'(A20)')ARQENT

!*************************************************************************************************
      
C      CALL DATE_AND_TIME(TIMENOW(1), TIMENOW(2), TIMENOW(3), DATE_TIME)
      WRITE(*,*) 'ARQUIVO DE ENTRADA ===> ', ARQENT
C      WRITE(*,*) 'ARQUIVO DE SAIDA   ===> ',FR,'W',TIMENOW(1),"-"
C	*,DATE_TIME(5),"-",DATE_TIME(6),"-",DATE_TIME(7),"-",ARQENT
      OPEN(LEC,FILE=ARQENT)
      
      CALL INPUT(XXC,YYC,X,Y,KODE,FI,NOP,LOCC,IDUP,NX,SAI,ARQENT,FR)
      NT=NP+NPI 
	WRITE (*,*) 'NP = ',NP
	WRITE (*,*) 'NPI = ',NPI 
	WRITE (*,*) 'NT = ',NT 
 
      !CALL DATE_AND_TIME(TIME=TEMPO1)

      CALL FMAT(X,Y,G,H,FI,DFI,KODE,NOP,IDUP,A,B,CB,XX,YY,XXC,YYC,NX,FR)
  
      CALL INTER(FI,DFI,KODE,NX)

	!CALCULO DO TEMPO DE PROCESSAMENTO
      !CALL DATE_AND_TIME(TIME=TEMPO2)      
      !TEMPO=CALCULA_TEMPO(TEMPO1,TEMPO2)

      CALL OUTPUT (X,Y,FI,DFI,NX,FR)
      STOP
      END















!	REAL*8 FUNCTION CALCULA_TEMPO(TEMPO1,TEMPO2)
!	IMPLICIT NONE
!	REAL*8 TEMP1(4),TEMP2(4)
!	CHARACTER TEMPO1*10,TEMPO2*10,AUX*2,AUX2*3
!
!	AUX=TEMPO1(1:2)
!	READ(AUX,*) TEMP1(1)
!	AUX=TEMPO1(3:4)
!	READ(AUX,*) TEMP1(2)
!	AUX=TEMPO1(5:6)
!	READ(AUX,*) TEMP1(3)
!	AUX2=TEMPO1(8:10)
!	READ(AUX2,*) TEMP1(4)
!	AUX=TEMPO2(1:2)
!	READ(AUX,*) TEMP2(1)
!	AUX=TEMPO2(3:4)
!	READ(AUX,*) TEMP2(2)
!	AUX=TEMPO2(5:6)
!	READ(AUX,*) TEMP2(3)
!	AUX2=TEMPO2(8:10)
!	READ(AUX2,*) TEMP2(4)
!	IF (TEMP1(1).GT.TEMP2(1)) THEN
!	  TEMP2(1)=TEMP2(1)+24
!	END IF
!	TEMP1(1)=TEMP1(1)*3600+TEMP1(2)*60+TEMP1(3)+TEMP1(4)/1000
!	TEMP2(1)=TEMP2(1)*3600+TEMP2(2)*60+TEMP2(3)+TEMP2(4)/1000
!	CALCULA_TEMPO=TEMP2(1)-TEMP1(1)
!	END












      SUBROUTINE INPUT(XXC,YYC,X,Y,KODE,FI,NOP,LOCC,IDUP,NX,SAI,ARQENT,
     *FR)

	IMPLICIT NONE
	COMMON NE,NP,L,LEC,IMP,NPI,NT
	INTEGER NX,LEC,IMP,NE,NP,NPI,L,NT,I,LOCC(NX),KODE(NX)
	INTEGER IDUP(NX),NOP(NX,3),J
	REAL*8 XXC(NX),YYC(NX),X(NX),Y(NX),FI(NX),FR
      CHARACTER TITLE*18,ARQENT*20,ARQOUT*50,SAI*20,STRING2*10
      INTEGER*4 DATE_TIME(8)
      CHARACTER*8 TIMENOW(3)      
	

	!WRITE(*,'(A\)')' INFORME NOME DO ARQUIVO DE SAIDA --->'
      !READ(*,'(A20)')ARQOUT
      !WRITE (STRING2,'(F10.2)') FR
      
C	WRITE(*,*) 'ARQUIVO DE SAIDA   ===> ',FR,'W',TIMENOW(1),"-"
C	*,DATE_TIME(5),"-",DATE_TIME(6),"-",DATE_TIME(7),"-",ARQENT
      
      CALL DATE_AND_TIME(TIMENOW(1), TIMENOW(2), TIMENOW(3), DATE_TIME)
	ARQOUT = ARQENT//"-"//TIMENOW(1)//"-"//TIMENOW(2)//"-"//'.TXT'
	WRITE(*,*) 'ARQUIVO DE SAIDA   ===> ',ARQOUT
      OPEN(IMP,FILE=ARQOUT)
C

!*********************************************************************************
!**************FAZ A LEITURA DE DADOS CONTIDOS NO ARQUIVO DE PROBLEMA*************

      WRITE(IMP,100)
100   FORMAT(' ',120('*'))
      READ(LEC,150) TITLE
150   FORMAT(18A4)
      WRITE(IMP,250) TITLE
250   FORMAT(25X,18A4)
	READ(LEC,200) NE
	READ(LEC,200) NP
	READ(LEC,200) NPI
200   FORMAT(I5)
      WRITE(IMP,300) NE,NP,NPI
300   FORMAT(//'DATA'//2X,'NUMERO DE ELEMENTOS DE CONTORNO=',
     *I3//,2X,'NUMERO DE NÓS FUNCIONAIS=',I3//,2X,
     *'NUMERO DE PONTOS INTERNOS ONDE A FUNC. É CALCULADA='
     *,I3,//)

      WRITE(*,*) NE,NP,NPI
      WRITE(IMP,500)
500   FORMAT (//2X,'COORDENADAS DOS PONTOS FONTE DOS ELEMENTOS DE
     *CONTORNO',//4X,'PONTO',10X,'X',18X,'Y')




	NT=NP+NPI
      !A VARREDURA INCLUI PONTOS INTERNOS, QUE SÃO OS PONTOS FONTE
      DO 750 I=1,NT !FAZ A LEITURA DE CADA PONTO EM UM LOOP ATÉ A ANCORA (750)
	READ(LEC,600)J, X(I),Y(I)
600   FORMAT(I4,2F12.4)

C     WRITE(IMP,900) KODE(I),IDUP(I),DSIN(3.1415*Y(I))
	WRITE(IMP,700) I,X(I),Y(I)
700   FORMAT(5X,I4,2(5X,E14.7))
C	WRITE(IMP,700) X(I),Y(I)
C700  FORMAT(2F12.5)
750	CONTINUE

      WRITE(IMP,800)
800   FORMAT(//2X,'CONDICOES DE CONTORNO'//7X,'INDICE',3X,'NÓ',8X,'NÓ',
     *10X,'VALOR PRESCRITO')
      DO 20 I=1,NP
      READ(LEC,900) KODE(I),IDUP(I),FI(I)
900   FORMAT(I5,I6,F12.4)
 20   WRITE(IMP,950) I,KODE(I),IDUP(I),FI(I)
950   FORMAT (5X,I3,8X,I1,8X,I3,8X,E14.7)

	WRITE(IMP,880)
c880   FORMAT(//,2X,'INCIDENCE OF GEOMETRIC NODES'//,5X,' FIRST NODE',
c     16X,'SECOND NODE',/)
880   FORMAT(//,2X,'INCIDENCIA DOS NOS GEOMETRICOS'//,7X,'INDICE',5X,
     *'PRIM. NÓ',6X,'SEG. NÓ')

      DO 261 I=1,NE
      READ(LEC,920) NOP(I,1),NOP(I,2)
920   FORMAT(I5,I5)
	WRITE(IMP,960) I,NOP(I,1),NOP(I,2)
960   FORMAT(5X,I3,8X,I3,5X,I3)
261   CONTINUE

      RETURN
      END


      SUBROUTINE FMAT(X,Y,G,H,FI,DFI,KODE,NOP,IDUP,A,B,CB,XX,YY,XXC,YYC,
     *NX,FR)
      IMPLICIT NONE
	COMMON NE,NP,L,LEC,IMP,NPI,NT
      REAL*8 FR,I_INIC,J_INIC
	INTEGER CONT_UPRES,CONT_QPRES,CONT_INTF,NUM(NX),NUM_2(NX)
 	INTEGER NX,NOP(NX,3),IDUP(NX),L1,L3,I,NE,L2,L4,NP,IMP
	INTEGER NPI,NT,J,NG,L,LEC,KODE(NX),CON1,CON2,K,N1,N2,PRINTE
	INTEGER IUU,JUU,IQQ,JQQ,IUQ,JUQ,IQU,JQU,KA,KB
	REAL*8 XD(NX),X(NX),YD(NX),Y(NX),XX(NX),YY(NX),HG1,HG2
	REAL*8 G(NX,NX),H(NX,NX),H1,H2,G1,G2,DX1,DX2,GG1,GG2
	REAL*8 DY1,DY2,EX1,EX2,EY1,EY2,TA,RA,C(NX,NX),FDO(NX),GE
	REAL*8 P(NX,NX),CD(NX),D,R,TOK(NX,NX),ALFA(NX,NX),TETA
	REAL*8 GG,ONETA(NX),CH,DFI(NX),CB(NX),FI(NX),Q(NX,NX)
	REAL*8 A(NX,NX),B(NX,NX),CC(NX,NX),DC(NX),AG,K1,K2,PI
	REAL*8 SLAMB(NX),ULAMB(NX,NX),CI(NX,NX),XXC(NX),YYC(NX),DIST,ALA
	REAL*8 FF(NX,NX),GGM(NX,NX),GGK(NX,NX),HGK(NX,NX),OMEGA
	REAL*8 HUU(NX,NX),HQQ(NX,NX),HQU(NX,NX)
	REAL*8 SUU(NX,NX),SQQ(NX,NX),SQU(NX,NX),SUQ(NX,NX)
	REAL*8 WUU(NX,NX),WQQ(NX,NX),WQU(NX,NX),WUQ(NX,NX)
	REAL*8 HUQ(NX,NX),CCUQ(NX,NX),CCQU(NX,NX),CCUU(NX,NX),CCQQ(NX,NX)
	REAL*8 GUQ(NX,NX),GQU(NX,NX),GUU(NX,NX),GQQ(NX,NX),CCBAR(NX,NX)
	REAL*8 DOMA(NX,NX),DOMB(NX,NX),DOMC(NX,NX),DOMD(NX,NX),HBAR(NX,NX)
	REAL*8 DOME(NX,NX)
	REAL*8 TERM_QU_1(1,1),TERM_QU_2(1,1),TERM_QU_3(1,1)
	REAL*8 TERM_QU_4(1,1),TERM_QU_5(1,1),TERM_QU_6(1,1)
	REAL*8 TERM_QU_7(1,1),TERM_QU_8(1,1),TERM_QU_9(1,1)
	REAL*8 TERM_QU_10(1,1),TERM_QU_11(1,1),TERM_QU_12(1,1)
	REAL*8 TERM_QQ_1(1,1),TERM_QQ_2(1,1),TERM_QQ_3(1,1)
	REAL*8 TERM_QQ_4(1,1),TERM_QQ_5(1,1),TERM_QQ_6(1,1)
	REAL*8 TERM_QQ_7(1,1),TERM_QQ_8(1,1),TERM_QQ_9(1,1)
	REAL*8 TERM_QQ_10(1,1),TERM_QQ_11(1,1),TERM_QQ_12(1,1)
	REAL*8 MATRIZA(1,1),MATRIZB(1,1),MATRIZC(1,1)
	REAL*8 MATRIZD(1,1),MATRIZE(1,1)
	REAL*8 MATRIZA_LINHA(NX,NX),MATRIZB_LINHA(NX,NX)
C	REAL*8 TERM_QU_1(NX,NX),TERM_QU_2(NX,NX),TERM_QU_3(NX,NX)
C	REAL*8 TERM_QU_4(NX,NX),TERM_QU_5(NX,NX),TERM_QU_6(NX,NX)
C	REAL*8 TERM_QU_7(NX,NX),TERM_QU_8(NX,NX),TERM_QU_9(NX,NX)
C	REAL*8 TERM_QU_10(NX,NX),TERM_QU_11(NX,NX),TERM_QU_12(NX,NX)
C	REAL*8 TERM_QQ_1(NX,NX),TERM_QQ_2(NX,NX),TERM_QQ_3(NX,NX)
C	REAL*8 TERM_QQ_4(NX,NX),TERM_QQ_5(NX,NX),TERM_QQ_6(NX,NX)
C	REAL*8 TERM_QQ_7(NX,NX),TERM_QQ_8(NX,NX),TERM_QQ_9(NX,NX)
C	REAL*8 TERM_QQ_10(NX,NX),TERM_QQ_11(NX,NX),TERM_QQ_12(NX,NX)
C	REAL*8 MATRIZA(NX,NX),MATRIZB(NX,NX),MATRIZC(NX,NX)
C	REAL*8 MATRIZD(NX,NX),MATRIZE(NX,NX)
	REAL*8 TAK(NX,NX),EIGV(NX)
	PARAMETER (PI=3.141592)
C
      
      ! XX E YY SERÃO AS COORDENADAS ORIGINAIS
      ! X E  Y  SERÃO AS COORDENADAS MODIFICADAS
      DO 1 I=1,NP
	XX(I)=X(I)
	YY(I)=Y(I)
1     CONTINUE
          
	PRINTE=1
C
C     ROTINA PARA AFASTAR OS PONTOS NODAIS DUPLOS DA QUINA DAS ARESTAS
C
	DIST=0.02 !PORCENTAGEM DO AFASTAMENTO DO ELEMENTO DA ARESTA
C	KODE(0)=1
	DO 156 I=1,NE
		L1=NOP(I,1)
		L3=IDUP(L1)
		IF (L3.EQ.0) GO TO 153
			L2=NOP(I,2)
			X(L1)=X(L1)+DIST*(X(L2)-X(L1))
			Y(L1)=Y(L1)+DIST*(Y(L2)-Y(L1))
C			ALA=KODE(L1)+KODE(L3)
C			IF(ALA.NE.0) GO TO 152
C152			CONTINUE
C			GO TO 154
153		CONTINUE
154		CONTINUE
		L2=NOP(I,2)
		L4=IDUP(L2)
		IF (L4.EQ.0) GO TO 155
		X(L2)=X(L2)-DIST*(X(L2)-X(L1))
		Y(L2)=Y(L2)-DIST*(Y(L2)-Y(L1))
C		ALA=KODE(L2)+KODE(L4)
C		IF (ALA.NE.0) GO TO 155
155		CONTINUE
156   CONTINUE

      WRITE(IMP,*)'NOVAS COORDENADAS DOS NOS DUPLOS'
	DO 17 I=1,NP
		WRITE(IMP,181)X(I),Y(I)
 181		FORMAT(2(3X,F8.4))
 17   CONTINUE
C
C      FORMAÇÃO DAS MATRIZES H, G E DO TERMO INDEPENDENTE HGK TIPO GALERKIN
C
      DO 10 I=1,NT
		DO 10 J=1,NT
			G(I,J)=0    !INICIAR G COM ZEROS
			H(I,J)=0    !INICIAR H COM ZEROS
 10   CONTINUE

  	DO 12 I=1,NP ! Nº PONTOS FONTE (SOMENTE PTS DO CONTORNO AQUI)
	DO 18 J=1,NE ! Nº ELEMENTOS QUE SERÃO INTEGRADOS
		L1=NOP(J,1)  ! PRIMEIRO PONTO DO SEGMENTO QUE FORMA O ELEMENTO
		L2=NOP(J,2)  ! SEGUNDO PONTO DO SEGMENTO QUE FORMA O ELEMENTO  (COM L1 E L2 TENHO O TAMANHO DO ELEMENTO)
  		
		IF(I.EQ.L1)GO TO 20 ! SE O PONTO FONTE É IGUAL AO PRIMEIRO PONTO DO ELEMENTO
		IF(I.EQ.L2)GO TO 22 ! SE O PONTO FONTE É IGUAL AO SEGUNDO PONTO DO ELEMENTO
		
		CALL INTE(X(I),Y(I),XX(L1),YY(L1),XX(L2),YY(L2),H1,H2,
     *G1,G2,DX1,DX2,DY1,DY2,EX1,EX2,EY1,EY2)
		CALL GALERK1(X(I),Y(I),XX(L1),YY(L1),XX(L2),YY(L2),
     *HG1,HG2,GG1,GG2)
		H(I,L2)=H(I,L2)+H2
		H(I,L1)=H(I,L1)+H1
		G(I,L2)=G(I,L2)+G2
		G(I,L1)=G(I,L1)+G1

		HGK(I,L2)=HGK(I,L2)+HG2
		HGK(I,L1)=HGK(I,L1)+HG1
		GGK(I,L2)=GGK(I,L2)+GG2
		GGK(I,L1)=GGK(I,L1)+GG1
C
	GO TO 26
  20  CONTINUE
      IF(IDUP(I).NE.0)GO TO 944 !SE IDUP(PTO KSI) != 0 (SE PONTO DE CANTO)
      CALL INLO(XX(L1),YY(L1),XX(L2),YY(L2),G1,G2) !SE IDUP(PTO KSI) = 0 (SE PONTO DE MEIO)
	GO TO 3
944   CONTINUE
	CALL INLO1(X(L1),Y(L1),XX(L1),YY(L1),XX(L2),YY(L2),G1,G2) !SE IDUP(PTO KSI) != 0 (SE PONTO DE CANTO)
  3   CONTINUE
      CALL GALERK2(XX(L1),YY(L1),XX(L2),YY(L2),GG1,GG2) !VERIFICAR RESULTADO DA INTEGRAÇÃO DIRETA
	G(I,L1)=G(I,L1)+G1
	H(I,L1)=H(I,L1)+0.0
 	G(I,L2)=G(I,L2)+G2
	H(I,L2)=H(I,L2)+0.0
      GGK(I,L1)=GGK(I,L1)+GG1
	GGK(I,L2)=GGK(I,L2)+GG2

	GO TO 26
  22  CONTINUE
	IF(IDUP(I).NE.0)GO TO 946
      CALL INLO(XX(L1),YY(L1),XX(L2),YY(L2),G1,G2)
	GO TO 4
946   CONTINUE
	CALL INLO1(X(L2),Y(L2),XX(L1),YY(L1),XX(L2),YY(L2),G1,G2)
   4  CONTINUE
      CALL GALERK2(XX(L1),YY(L1),XX(L2),YY(L2),GG1,GG2)  !VERIFICAR RESULTADO DA INTEGRAÇÃO DIRETA
	G(I,L1)=G(I,L1)+G2
 	H(I,L1)=H(I,L1)+0.0
	G(I,L2)=G(I,L2)+G1
	H(I,L2)=H(I,L2)+0.0
	GGK(I,L1)=GGK(I,L1)+GG2
	GGK(I,L2)=GGK(I,L2)+GG1
 !     CALL INLO(X(L1),Y(L1),X(L2),Y(L2),G1,G2)
	!CALL GALERK2(X(L1),Y(L1),X(L2),Y(L2),GG1,GG2)  !VERIFICAR RESULTADO DA INTEGRAÇÃO DIRETA
	!G(I,L1)=G(I,L1)+G2
 !	H(I,L1)=H(I,L1)+0.0
	!G(I,L2)=G(I,L2)+G1
	!H(I,L2)=H(I,L2)+0.0
	!GGK(I,L1)=GGK(I,L1)+GG2
	!GGK(I,L2)=GGK(I,L2)+GG1
  26  CONTINUE
  18  CONTINUE
  12  CONTINUE
C  
C	 CONSTRUÇÃO DOS TERMOS DA DIAGONAL DE H
C 
 	DO 29 I=1,NP 
  	TA=0.0 
	DO 28 J=1,NP  !PORQUE NP E NAO NE (DA CERTO POIS H(I,J) FOI INICIALIZADO COM ZEROS DO TAMANHO NT,NT) VAI SOMAR MAIS 04 ZEROS.
	TA=TA+H(I,J) 
 28   CONTINUE
      H(I,I)=-TA !O VALOR DA DIAGONAL DE H É A SOMA DA LINHA COM SINAL CONTRÁRIO (EXCETO A PRÓPRIA DIAGONAL)
 29   CONTINUE
C
C 	 MONTAGEM DA MATRIZ DE INTERPOLAÇÃO DE TERMOS DE DOMÍNIO (F-¹)
C      
C	NG=NP+L
	CONTINUE
      DO 23 I=1,NT
	DO 23 J=1,NT
 	RA=DSQRT((X(I)-X(J))**2+(Y(I)-Y(J))**2) !FUNÇÃO RADIAL SERÁ "R²*LN(R)" - DISTÂNCIA EUCLIDIANA DO PONTO FONTE COM OS PTS SUBSEQUENTES.
      IF(RA.EQ.0)GO TO 222 !SE O PONTO ANALISADO FOR O PONTO FONTE (KSI)
      C(I,J)=RA*RA*DLOG(RA) !FUNÇÃO RADIAL => R²*LN(R)
C	C(I,J)=RA
	GO TO 23
222	C(I,J)=0.
23    CONTINUE
C
C	WRITE(IMP,*)'MATRIZ C'
C      DO 5423 I=1,NT
C    	WRITE(IMP,5410)(C(I,J),J=1,NT)
C5423   CONTINUE
C
C	INVERSÃO DA MATRIZ DE INTERPOLAÇÃO (F-¹)
	CALL MATRIZINVERSA(C,NT)
C
C	INTRODUÇÃO DE PONTOS INTERNOS CONSTITUTIVOS	- PONTOS FONTE - EM H E G
      IF (NPI.EQ.0)GO TO 132 !SE O NUMERO DE PONTOS INTERNOS FOR NULO
	DO 55 I=NP+1,NT !CONTROLE I (NUMERO DE LINHAS DOS PONTOS INTERNOS À PARTIR DO ULTIMO PONTO DO CONTORNO)
	DO 55 J=1,NE !CONTROLE J (NUMERO DE COLUNAS = NUMERO DE ELEMENTOS)
	L1=NOP(J,1) !PONTO 1 DO ELEMENTO
	L2=NOP(J,2) !PONTO 2 DO ELEMENTO
      CALL INTE(X(I),Y(I),XX(L1),YY(L1),XX(L2),YY(L2),H1,H2,G1,G2,            !CALCULO DA INTEGRAL H E G
     *DX1,DX2,DY1,DY2,EX1,EX2,EY1,EY2)
      CALL GALERK1(X(I),Y(I),XX(L1),YY(L1),XX(L2),YY(L2),HG1,HG2,
     *GG1,GG2)     !CALCULO DA INTEGRAL W E S
 	H(I,L2)=H(I,L2)+H2
      H(I,L1)=H(I,L1)+H1
      G(I,L2)=G(I,L2)+G2
      G(I,L1)=G(I,L1)+G1
	HGK(I,L2)=HGK(I,L2)+HG2
      HGK(I,L1)=HGK(I,L1)+HG1
      GGK(I,L2)=GGK(I,L2)+GG2
      GGK(I,L1)=GGK(I,L1)+GG1
55    CONTINUE
C
C	 DIAGONAIS DE H	E G (DOS PONTOS INTERNOS)
C
	DO 58 I=NP+1,NT
	H(I,I)=1. !PONTO INTERNO É UMA MATRIZ IDENTIDADE
	G(I,I)=0. !PONTO INTERNO É IGUAL A ZERO
58    CONTINUE
132   CONTINUE
134   CONTINUE
C
C	DECLARAÇÃO DE OMEGA
C
C	OMEGA=FR*FR
	OMEGA=0.
C
C	 SOMA DAS MATRIZES AFINS
C
C	DO 5421 I=1,NT
C	DO 5421 J=1,NT
C	WRITE(*,*) 'H(',I,',',J,')=',H(I,J) 
C	H(I,J)=H(I,J)-OMEGA*HGK(I,J) !H - OMEGA*(W)     OS TERMOS SE SOMAM ?
C	WRITE(*,*) 'H(',I,',',J,')=',H(I,J)
C	G(I,J)=G(I,J)-OMEGA*GGK(I,J) !G - OMEGA*(S)     OS TERMOS SE SOMAM ?
C5421  CONTINUE
C
C	 IMPRESSÃO DE MATRIZES GERAIS

C    	WRITE(IMP,*)'MATRIZ C INVERTIDA GERAL'
C     DO 5420 I=1,NT
C   	WRITE(IMP,5410)(C(I,J),J=1,NT)
C5410  FORMAT(10F9.4)
C5420  CONTINUE
C
C	  WRITE(IMP,*)'MATRIZ H GERAL'
C      DO 5450 I=1,NT
C	  WRITE(IMP,5460)(H(I,J),J=1,NT)
C5460   FORMAT(10F9.4)
C5450   CONTINUE
C
C	 WRITE(IMP,*)'MATRIZ HGK GERAL'
C      DO 5455 I=1,NT
C	   WRITE(IMP,5460)(HGK(I,J),J=1,NT)
C5455   CONTINUE
C
C	 VARREDURA NOS PONTOS DE INTERPOLAÇÃO I ATÉ NE; OS PONTOS CSI NESTE "DO" INICIAL 
C      VÃO ATÉ O NÚMERO DE PONTOS NODAIS NP
C 
       !CALCULO DA FUNÇÃO G* = ULAMB
	DO 24 I=1,NT
	DO 24 J=1,NT
	RA=DSQRT((X(I)-X(J))**2+(Y(I)-Y(J))**2) !CALCULA O RAIO
	IF(RA.EQ.0)GO TO 25 !VERIFICA SE O PONTO INTERPOLANTE É IGUAL AO PONTO FONTE
      ULAMB(I,J)=(RA**2)*(1.-DLOG(RA))/(8*3.1415926) !CALCULA (R²/8PI)*(1-LN(R)) => ((MATRIZ => G*))
	GO TO 244
25    ULAMB(I,J)=0.
244   CONTINUE  
24    CONTINUE
C
C		 WRITE(IMP,*)'MATRIZ ULAMB'
C      DO 5457 I=1,NT
C	   WRITE(IMP,5460)(ULAMB(I,J),J=1,NT)
5457   CONTINUE

C
C	 GERAÇÃO DAS INTEGRAIS DE NETA (CONTROLE I)
C
	DO 34 I=1,NT
 	DO 34 J=1,NE
	L1=NOP(J,1) !PONTO 1 DO ELEMENTO
	L2=NOP(J,2) !PONTO 2 DO ELEMENTO
C	WRITE(IMP,*)'I=',I
C	WRITE(IMP,*)'J=',J
C	WRITE(IMP,*)'L1=',L1
C	WRITE(IMP,*)'L2=',L2
  	IF(I.EQ.J)GO TO 21 !SE FOR DIAGONAL
      !CALL INTE1(X(I),Y(I),X(L1),Y(L1),X(L2),Y(L2),GG)
      CALL INTE1(X(I),Y(I),XX(L1),YY(L1),XX(L2),YY(L2),GG)
C	WRITE(IMP,*)'GG',GG
     	GO TO 36
  21  CONTINUE
      GG=0.
  36  CONTINUE
C
C	NETA É FUNÇÃO DO PONTO BASE, COINCIDENTE COM OS PONTOS FONTE NESTE CASO E DO ELEMENTO NE (GAMA) DE INTEGRAÇÃO
C
	ONETA(I)=ONETA(I)+GG !ESTA SOMANDO O VALOR DA INTEGRAL DE CADA ELEMENTO PARA CADA PONTO FONTE ??? PQ???
34    CONTINUE

C
C     DOS PRODUTOS FINAIS
C
      DO 35 J=1,NT
      DO 35 K=1,NT
      SLAMB(J)=SLAMB(J)+ONETA(K)*C(K,J) !ONETA É UM VETOR ?
 35   CONTINUE

C 	  WRITE(IMP,*)'MATRIZ SLAMB(J)'
C	  WRITE(IMP,5460)(SLAMB(J),J=1,NT)
C

C
C	PRODUTO SLAMB PELA MATRIZ DIAGONAL COM TERMO SINGULAR
C
      DO 42 I=1,NT
      DO 42 J=1,NT
 	  P(I,J)=SLAMB(J)*ULAMB(J,I)
C	  A(I,I)=A(I,I)+P(I,J)
42    CONTINUE
C
C
C		WRITE(IMP,*)'MATRIZ P(I,J)'
C		DO 5477 I=1,NT
C		WRITE(IMP,5460)(P(I,J),J=1,NT)
5477		CONTINUE
C		
C		WRITE(IMP,*)'MATRIZ A(I,J)'
C		DO 5479 I=1,NT
C		WRITE(IMP,5460)(A(I,J),J=1,NT)
5479		CONTINUE
5478		CONTINUE


		DO 115 I=1,NT
 		DO 115 J=1,NT
C		EXPONENCIAL 
C		CC(I,J)=H(I,J)+ALFA(I,J)
C		HARMONICO
		CC(I,J)=H(I,J)+P(I,J)*OMEGA*OMEGA !TROCA DE LADO P(I,J) (POR ISSO FICOU POSITIVO) E SOMA COM H(I,J)
115		CONTINUE
C95		CONTINUE
		
		DO 152 J=1,NP !CONTROLE I => ATÉ O NÚMERO PTOS CONTORNO
			IF (KODE(J)) 140,140,150 !ANALISE SE É FLUXO(1) OU POTENCIAL(0) PRESCRITO
140			CONTINUE !SE FOR POTENCIAL PRESCRITO
				DO 151 I=1,NP+NPI
					CH=G(I,J)
					G(I,J)=-CC(I,J)
					CC(I,J)=-CH
151				CONTINUE
150			CONTINUE !SE FOR FLUXO PRECRITO
152		CONTINUE

      WRITE(IMP,*)'  '
      WRITE(IMP,*)'VALORES DE DFI  ************************************'

		DO 161 I=1,NT
			DFI(I)=0.
			DO 160 J=1,NT
				DFI(I)=DFI(I)+G(I,J)*FI(J)
160			CONTINUE
			WRITE(IMP,9999)I,DFI(I)
9999			FORMAT(2(3X,I4,F8.4))
161		CONTINUE


 		JUU=0 
		JQQ=0 
		DO 422 J=1,NT
			IUU=0
			IQU=0
			IUQ=0
			IQQ=0
			KA=KODE(J)
			IF(J.LE.NP)GO TO 367
				KA=1
367			IF(KA.EQ.1)GO TO 39
				JUU=JUU+1
				DO 38 I=1,NT
					KB=KODE(I)
					IF(I.LE.NP)GO TO 377
 						KB=1
377 					IF(KB.EQ.1)GO TO 366
						IUU=IUU+1
						HUU(IUU,JUU)=H(I,J)
						CCUU(IUU,JUU)=CC(I,J)
						GUU(IUU,JUU)=G(I,J)
						WUU(IUU,JUU)=HGK(I,J)
						SUU(IUU,JUU)=GGK(I,J)
					!WRITE(*,*) 'SUU(',IUU,';',JUU,') = ',SUU(IUQ,JQQ)
					GO TO 37
366					CONTINUE
						IQU=IQU+1
						HQU(IQU,JUU)=H(I,J)
						CCQU(IQU,JUU)=CC(I,J)
						GQU(IQU,JUU)=G(I,J)
						WQU(IQU,JUU)=HGK(I,J)
						SQU(IQU,JUU)=GGK(I,J)
					!WRITE(*,*) 'SQU(',IQU,';',JUU,') = ',SQU(IUQ,JQQ)
37					CONTINUE
38				CONTINUE
			GO TO 413
39 			JQQ=JQQ+1
			DO 412 I=1,NT
				KB=KODE(I)
				IF(I.LE.NP)GO TO 397
					KB=1
397				IF(KB.EQ.0)GO TO 40
					IQQ=IQQ+1
					HQQ(IQQ,JQQ)=H(I,J)
					CCQQ(IQQ,JQQ)=CC(I,J)
					GQQ(IQQ,JQQ)=G(I,J)
					WQQ(IQQ,JQQ)=HGK(I,J)
					SQQ(IQQ,JQQ)=GGK(I,J)
					!WRITE(*,*) 'SQQ(',IQQ,';',JQQ,') = ',SQQ(IUQ,JQQ)
				GO TO 41 
40				CONTINUE
					IUQ=IUQ+1
					HUQ(IUQ,JQQ)=H(I,J)
					CCUQ(IUQ,JQQ)=CC(I,J)
					GUQ(IUQ,JQQ)=G(I,J)
					WUQ(IUQ,JQQ)=HGK(I,J)
					SUQ(IUQ,JQQ)=GGK(I,J)
					!WRITE(*,*) 'SUQ(',IUQ,';',JQQ,') = ',SUQ(IUQ,JQQ)
41				CONTINUE
412			CONTINUE
413			CONTINUE
422		CONTINUE
C
C
C
C
C	CRIAÇÃO DAS MATRIZES AUXILIARES DE AUTOVALOR
	CALL MATRIZINVERSA(GUU,JUU)
	CALL MATRIZINVERSA(SUU,JUU)


	DO 3103 I=1,JQQ
 		DO 3104 J=1,JUU
			DO 3102 K=1,JUU
			TERM_QU_1(I,J)=TERM_QU_1(I,J)+GQU(I,K)*SUU(K,J)				
			TERM_QU_2(I,J)=TERM_QU_2(I,J)+GQU(I,K)*SUU(K,J)
			TERM_QU_3(I,J)=TERM_QU_3(I,J)+GQU(I,K)*GUU(K,J)				
			TERM_QU_4(I,J)=TERM_QU_4(I,J)+SQU(I,K)*SUU(K,J)
			TERM_QU_5(I,J)=TERM_QU_5(I,J)+GQU(I,K)*SUU(K,J)
			TERM_QU_6(I,J)=TERM_QU_6(I,J)+GQU(I,K)*GUU(K,J)
			TERM_QU_7(I,J)=TERM_QU_7(I,J)+SQU(I,K)*SUU(K,J)
			TERM_QU_8(I,J)=TERM_QU_8(I,J)+SQU(I,K)*GUU(K,J)
			TERM_QU_9(I,J)=TERM_QU_9(I,J)+GQU(I,K)*GUU(K,J)
			TERM_QU_10(I,J)=TERM_QU_10(I,J)+SQU(I,K)*SUU(K,J)
			TERM_QU_11(I,J)=TERM_QU_11(I,J)+SQU(I,K)*GUU(K,J)
			TERM_QU_12(I,J)=TERM_QU_12(I,J)+SQU(I,K)*GUU(K,J)
3102			CONTINUE
			DO 3105 K=1,JQQ
			TERM_QQ_1(I,J)=TERM_QQ_1(I,J)+TERM_QU_1(I,J)*HUQ(K,J)
			TERM_QQ_2(I,J)=TERM_QQ_2(I,J)+TERM_QU_2(I,J)*WUQ(K,J)
			TERM_QQ_3(I,J)=TERM_QQ_3(I,J)+TERM_QU_3(I,J)*HUQ(K,J)
			TERM_QQ_4(I,J)=TERM_QQ_4(I,J)+TERM_QU_4(I,J)*HUQ(K,J)
			TERM_QQ_5(I,J)=TERM_QQ_5(I,J)+TERM_QU_5(I,J)*CCUQ(K,J)
			TERM_QQ_6(I,J)=TERM_QQ_6(I,J)+TERM_QU_6(I,J)*WUQ(K,J)
			TERM_QQ_7(I,J)=TERM_QQ_7(I,J)+TERM_QU_7(I,J)*WUQ(K,J)
			TERM_QQ_8(I,J)=TERM_QQ_8(I,J)+TERM_QU_8(I,J)*HUQ(K,J)
			TERM_QQ_9(I,J)=TERM_QQ_9(I,J)+TERM_QU_9(I,J)*HUQ(K,J)
			TERM_QQ_10(I,J)=TERM_QQ_10(I,J)+TERM_QU_10(I,J)*CCUQ(K,J)
			TERM_QQ_11(I,J)=TERM_QQ_11(I,J)+TERM_QU_11(I,J)*WUQ(K,J)
			TERM_QQ_12(I,J)=TERM_QQ_12(I,J)+TERM_QU_12(I,J)*CCUQ(K,J)
3105			CONTINUE
3104		CONTINUE
3103	CONTINUE






C	DO 3108 I=1,JQQ
C	DO 3108 J=1,JQQ
C	WRITE(*,*) 'TERM_QQ_1(',I,',',J,') = ', TERM_QQ_1(I,J)
C3108	CONTINUE


C	DO 3104 I=1,JQQ
C 		DO 3104 J=1,JQQ
C		
C		MATRIZA(I,J)=TERM_QQ_1(I,J)
C			
C		MATRIZB(I,J)=HQQ(I,J)+TERM_QQ_2(I,J)
C		MATRIZB(I,J)=MATRIZB(I,J)+TERM_QQ_3(I,J)+TERM_QQ_4(I,J)
C			
C		MATRIZC(I,J)=WQQ(I,J)+TERM_QQ_5(I,J)+TERM_QQ_6(I,J)
C		MATRIZC(I,J)=MATRIZC(I,J)+TERM_QQ_7(I,J)+TERM_QQ_8(I,J)
C		
C		MATRIZD(I,J)=TERM_QQ_9(I,J)+TERM_QQ_10(I,J)
C		MATRIZD(I,J)=MATRIZD(I,J)+TERM_QQ_11(I,J)-CCQQ(I,J)
C			
C		MATRIZE(I,J)=TERM_QQ_12(I,J)
C		WRITE(*,*) 'MATRIZD(',I,',',J,') = ', MATRIZD(I,J)
C		
C3104	CONTINUE


	DO 3200 I=1,JQQ
	DO 3201 J=1,JQQ
C	MATRIZA_LINHA(I+0*JQQ,J+0*JQQ)=0
	MATRIZA_LINHA(I+0*JQQ,J+1*JQQ)=(TERM_QQ_9(I,J)+TERM_QQ_10(I,J)
	&+TERM_QQ_11(I,J)-CCQQ(I,J))
C	MATRIZA_LINHA(I+0*JQQ,J+2*JQQ)=0
C	MATRIZA_LINHA(I+0*JQQ,J+3*JQQ)=0

	MATRIZA_LINHA(I+1*JQQ,J+0*JQQ)=(TERM_QQ_12(I,J))
	MATRIZA_LINHA(I+1*JQQ,J+1*JQQ)=(TERM_QQ_9(I,J)+TERM_QQ_10(I,J)
	&+TERM_QQ_11(I,J)-CCQQ(I,J))
	MATRIZA_LINHA(I+1*JQQ,J+2*JQQ)=(WQQ(I,J)+TERM_QQ_5(I,J)
	&+TERM_QQ_6(I,J)+TERM_QQ_7(I,J)+TERM_QQ_8(I,J))
	MATRIZA_LINHA(I+1*JQQ,J+3*JQQ)=HQQ(I,J)+TERM_QQ_2(I,J)

C	MATRIZA_LINHA(I+2*JQQ,J+0*JQQ)=0
C	MATRIZA_LINHA(I+2*JQQ,J+1*JQQ)=0
	MATRIZA_LINHA(I+2*JQQ,J+2*JQQ)=(WQQ(I,J)+TERM_QQ_5(I,J)
	&+TERM_QQ_6(I,J)+TERM_QQ_7(I,J)+TERM_QQ_8(I,J))
C	MATRIZA_LINHA(I+2*JQQ,J+3*JQQ)=0

C	MATRIZA_LINHA(I+3*JQQ,J+0*JQQ)=0
C	MATRIZA_LINHA(I+3*JQQ,J+1*JQQ)=0
C	MATRIZA_LINHA(I+3*JQQ,J+2*JQQ)=0
	MATRIZA_LINHA(I+3*JQQ,J+3*JQQ)=(HQQ(I,J)+TERM_QQ_2(I,J)
	&+TERM_QQ_3(I,J)+TERM_QQ_4(I,J))


	MATRIZB_LINHA(I+0*JQQ,J+0*JQQ)=-(TERM_QQ_9(I,J)+TERM_QQ_10(I,J)
	&+TERM_QQ_11(I,J)-CCQQ(I,J))
C	MATRIZB_LINHA(I+0*JQQ,J+1*JQQ)=0
C	MATRIZB_LINHA(I+0*JQQ,J+2*JQQ)=0
C	MATRIZB_LINHA(I+0*JQQ,J+3*JQQ)=0

C	MATRIZB_LINHA(I+1*JQQ,J+0*JQQ)=0
C	MATRIZB_LINHA(I+1*JQQ,J+1*JQQ)=0
C	MATRIZB_LINHA(I+1*JQQ,J+2*JQQ)=0
	MATRIZB_LINHA(I+1*JQQ,J+3*JQQ)=(TERM_QQ_1(I,J))
C	WRITE(*,*) 'MATRIZB_LINHA(',I+1*JQQ,',',J+3*JQQ,')=',
C	&MATRIZB_LINHA(I+1*JQQ,J+3*JQQ)

C	MATRIZB_LINHA(I+2*JQQ,J+0*JQQ)=0
	MATRIZB_LINHA(I+2*JQQ,J+1*JQQ)=-(WQQ(I,J)+TERM_QQ_5(I,J)
	&+TERM_QQ_6(I,J)+TERM_QQ_7(I,J)+TERM_QQ_8(I,J))
C	MATRIZB_LINHA(I+2*JQQ,J+2*JQQ)=0
C	MATRIZB_LINHA(I+2*JQQ,J+3*JQQ)=0

C	MATRIZB_LINHA(I+3*JQQ,J+0*JQQ)=0
C	MATRIZB_LINHA(I+3*JQQ,J+1*JQQ)=0
	MATRIZB_LINHA(I+3*JQQ,J+2*JQQ)=-(HQQ(I,J)+TERM_QQ_2(I,J)
	&+TERM_QQ_3(I,J)+TERM_QQ_4(I,J))
C	MATRIZB_LINHA(I+3*JQQ,J+3*JQQ)=0

3201	CONTINUE
3200	CONTINUE


C	DO 3107 I=1,(4*JQQ)
C	DO 3107 J=1,(4*JQQ)
C	WRITE(*,*) 'MATRIZB_LINHA(',I,',286) = ',MATRIZB_LINHA(I,286)
C	WRITE(*,*) 'MATRIZB_LINHA(286,',J,') = ',MATRIZB_LINHA(286,J)
C	WRITE(*,*) 'MATRIZB(',I,',',J,') = ',MATRIZB(I,J)
C3107	CONTINUE

	CALL AUTOV(MATRIZA_LINHA,MATRIZB_LINHA,4*JQQ,FI,DFI,1,4*NT,4*JUU)		





C	DO 3106 I=(JQQ+1),(2*JQQ)
C 		DO 3106 J=1,JQQ
C		
C3106	CONTINUE
C	DO 3107 I=(2*JQQ+1),(3*JQQ)
C 		DO 3107 J=1,JQQ
C		
C3107	CONTINUE
C	DO 3108 I=(3*JQQ+1),(4*JQQ)
C 		DO 3108 J=1,JQQ
C		
C3108	CONTINUE


C	DO 3102 I=1,JUU
C		DO 3102 J=1,JQQ
C			DO 3102 K=1,JUU
C				DOMA(I,J)=DOMA(I,J)+GUU(I,K)*HUQ(K,J)
C				DOMB(I,J)=DOMB(I,J)+GUU(I,K)*CCUQ(K,J)
C3102	CONTINUE
C	DO 3103 I=1,JQQ
C 		DO 3103 J=1,JQQ
C			DO 3103 K=1,JUU
C				DOMC(I,J)=DOMC(I,J)+GQU(I,K)*DOMA(K,J)
C				DOMD(I,J)=DOMD(I,J)+GQU(I,K)*DOMB(K,J)
C3103	CONTINUE
C	DO 3104 I=1,JQQ
C 		DO 3104 J=1,JQQ
C			HBAR(I,J)=HQQ(I,J)-DOMC(I,J)
C			CCBAR(I,J)=CCQQ(I,J)-DOMD(I,J)
C3104	CONTINUE
C
C
	



C	CHAMADA DA ROTINA DE RESOLUCAO DO PROBLEMA DE AUTOVALOR GENERALIZADO
C	 [A]{X}=LAMBDA[B]{X}
C     CALL SLNPD(CC,DFI,NT,NX)



      RETURN
      END
